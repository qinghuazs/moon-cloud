# Moon Spring Boot Starter Validator 使用文档

**版本：1.0.0**
**更新日期：2024-09**

## 一、简介

Moon Spring Boot Starter Validator 是一个基于 Spring Boot 3.x 的验证器扩展模块，提供了丰富的自定义验证注解，专门针对中国本地化业务场景进行优化。该模块基于 Jakarta Validation API 3.x 构建，无缝集成 Spring Boot 验证框架。

### 核心特性

- ✅ **Spring Boot 3.x 自动配置**：基于最新的自动配置机制，零配置即可使用
- ✅ **完整的验证逻辑**：不仅验证格式，还包含业务逻辑验证（如身份证校验码、信用代码校验等）
- ✅ **中国本地化优化**：针对中国特有的数据格式进行深度优化
- ✅ **高性能设计**：预编译正则表达式，单例模式，线程安全
- ✅ **丰富的验证器**：覆盖身份、金融、企业、网络、社交等多个领域

## 二、快速开始

### 2.1 引入依赖

```xml
<dependency>
    <groupId>com.mooncloud</groupId>
    <artifactId>moon-spring-boot-starter-validator</artifactId>
    <version>1.0.0</version>
</dependency>
```

### 2.2 基础使用示例

```java
import com.moon.cloud.validator.mobile.Mobile;
import com.moon.cloud.validator.idcard.IdCard;
import com.moon.cloud.validator.email.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class UserRegisterDTO {

    @NotBlank(message = "手机号不能为空")
    @Mobile(message = "手机号格式不正确")
    private String mobile;

    @NotBlank(message = "身份证号不能为空")
    @IdCard(message = "身份证号格式不正确")
    private String idCard;

    @Email(message = "邮箱格式不正确")
    private String email;
}
```

### 2.3 Controller 集成

```java
@RestController
@RequestMapping("/api/user")
public class UserController {

    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody UserRegisterDTO dto) {
        // 验证通过后的业务逻辑
        return ResponseEntity.ok("注册成功");
    }
}
```

## 三、验证器详细说明

### 3.1 身份信息类验证器

#### @Mobile - 手机号验证器

**功能特性：**
- 支持中国大陆所有运营商最新号段（包括中国广电192）
- 支持国际区号格式（+86、86前缀）
- 支持带空格和连字符的格式
- 提供运营商识别功能

**使用示例：**
```java
@Mobile
private String phone;

@Mobile(message = "请输入正确的手机号码")
private String mobile;
```

**支持的格式：**
```
13812345678      // 标准格式
+8613812345678   // 带国际区号
8613812345678    // 带国家码
138 1234 5678    // 带空格
138-1234-5678    // 带连字符
```

**运营商识别：**
```java
String carrier = MobileValidator.getCarrier("13812345678");
// 返回：中国移动
```

**支持的号段：**
- **中国移动**：134-139, 147, 148, 150-152, 157-159, 165, 172, 178, 182-184, 187-188, 195, 197, 198
- **中国联通**：130-132, 145, 146, 155-156, 166, 167, 171, 175-176, 185-186, 196
- **中国电信**：133, 149, 153, 173-174, 177, 180-181, 189, 190, 191, 193, 199
- **中国广电**：192

#### @IdCard - 身份证验证器

**功能特性：**
- 支持18位二代身份证号验证
- 验证地区码（省市区）合法性
- 验证出生日期合法性
- 使用ISO 7064:1983.MOD 11-2算法验证校验码
- 支持大小写X校验码

**使用示例：**
```java
@IdCard
private String idCard;

@NotBlank
@IdCard(message = "身份证号码无效")
private String identityCard;
```

**验证规则：**
1. **格式验证**：18位字符，前17位为数字，第18位为数字或X
2. **地区码验证**：前6位必须是有效的行政区划代码
3. **出生日期验证**：
   - 不能晚于当前日期
   - 不能早于1900年
   - 考虑闰年等日期合法性
4. **校验码验证**：按国标算法验证最后一位

#### @Email - 邮箱验证器

**功能特性：**
- 支持标准RFC邮箱格式
- 可配置是否允许子域名
- 可配置是否允许中文域名
- 支持多种特殊字符

**使用示例：**
```java
// 标准邮箱
@Email
private String email;

// 允许中文域名
@Email(allowChinese = true)
private String chineseEmail;

// 不允许子域名
@Email(allowSubdomain = false)
private String companyEmail;

// 组合配置
@Email(
    allowChinese = true,
    allowSubdomain = false,
    message = "邮箱格式不符合要求"
)
private String customEmail;
```

**参数说明：**

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| allowSubdomain | boolean | true | 是否允许子域名邮箱 |
| allowChinese | boolean | false | 是否允许中文域名 |
| message | String | "邮箱地址格式不正确" | 验证失败消息 |

### 3.2 金融支付类验证器

#### @BankCard - 银行卡验证器

**功能特性：**
- 使用Luhn算法验证银行卡号
- 支持16-19位银行卡号

**使用示例：**
```java
@BankCard
private String bankCardNumber;

@BankCard(message = "银行卡号无效")
private String cardNo;
```

#### @CVV - CVV码验证器

**功能特性：**
- 验证3-4位CVV安全码

**使用示例：**
```java
@CVV
private String cvv;

@CVV(message = "CVV码格式错误")
private String securityCode;
```

### 3.3 企业商务类验证器

#### @CreditCode - 统一社会信用代码验证器

**功能特性：**
- 验证18位统一社会信用代码
- 包含校验码算法验证
- 支持企业、机构等组织机构代码

**使用示例：**
```java
@CreditCode
private String creditCode;

@CreditCode(message = "统一社会信用代码无效")
private String unifiedSocialCreditCode;
```

#### @PlateNumber - 车牌号验证器

**功能特性：**
- 支持普通车牌（蓝牌、黄牌）
- 支持新能源车牌（小型、大型）
- 可配置验证特定类型车牌

**使用示例：**
```java
// 验证所有类型车牌
@PlateNumber
private String plateNumber;

// 只验证普通车牌
@PlateNumber(type = PlateNumber.PlateType.NORMAL)
private String normalPlate;

// 只验证新能源车牌
@PlateNumber(type = PlateNumber.PlateType.NEW_ENERGY)
private String newEnergyPlate;
```

**车牌类型：**
- `PlateType.ALL` - 所有类型
- `PlateType.NORMAL` - 普通车牌
- `PlateType.NEW_ENERGY` - 新能源车牌

#### @Telephone - 座机号码验证器

**功能特性：**
- 支持带区号格式（010-12345678）
- 支持不带区号格式（12345678）
- 支持分机号（010-12345678-1234）
- 支持400/800服务电话

**使用示例：**
```java
// 默认配置
@Telephone
private String phone;

// 必须包含区号
@Telephone(requireAreaCode = true)
private String officePhone;

// 不允许分机号
@Telephone(allowExtension = false)
private String directLine;

// 组合配置
@Telephone(
    requireAreaCode = true,
    allowExtension = true,
    message = "请输入正确的座机号码"
)
private String telephone;
```

**参数说明：**

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| requireAreaCode | boolean | false | 是否必须包含区号 |
| allowExtension | boolean | true | 是否允许分机号 |

### 3.4 网络技术类验证器

#### @IpAddress - IP地址验证器

**功能特性：**
- 支持IPv4地址验证
- 支持IPv6地址验证

**使用示例：**
```java
@IpAddress
private String ip;

@IpAddress(message = "IP地址格式错误")
private String serverIp;
```

#### @MacAddress - MAC地址验证器

**功能特性：**
- 支持冒号分隔格式（AA:BB:CC:DD:EE:FF）
- 支持连字符分隔格式（AA-BB-CC-DD-EE-FF）
- 支持无分隔符格式（AABBCCDDEEFF）
- 可配置分隔符类型

**使用示例：**
```java
// 默认冒号分隔
@MacAddress
private String mac;

// 指定连字符分隔
@MacAddress(separator = "-")
private String macWithHyphen;

// 允许无分隔符
@MacAddress(allowNoSeparator = true)
private String macFlexible;
```

**参数说明：**

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| separator | String | ":" | 分隔符（":"或"-"） |
| allowNoSeparator | boolean | false | 是否允许无分隔符格式 |

#### @Url - URL验证器

**功能特性：**
- 验证标准URL格式
- 支持HTTP/HTTPS协议

**使用示例：**
```java
@Url
private String website;

@Url(message = "请输入有效的网址")
private String homepage;
```

### 3.5 社交通讯类验证器

#### @QQNumber - QQ号验证器

**功能特性：**
- 验证5-12位QQ号
- 首位不能为0

**使用示例：**
```java
@QQNumber
private String qq;

@QQNumber(message = "QQ号格式不正确")
private String qqNumber;
```

#### @WeChatId - 微信号验证器

**功能特性：**
- 验证6-20位微信号
- 必须以字母开头
- 可包含字母、数字、下划线和减号

**使用示例：**
```java
@WeChatId
private String wechat;

@WeChatId(message = "微信号格式不正确")
private String wechatId;
```

### 3.6 其他常用验证器

#### @PostCode - 邮政编码验证器

**功能特性：**
- 验证6位中国邮政编码

**使用示例：**
```java
@PostCode
private String postCode;

@PostCode(message = "邮政编码格式不正确")
private String zipCode;
```

#### @BloodType - 血型验证器

**功能特性：**
- 支持A、B、AB、O型
- 支持Rh阴性/阳性标记

**使用示例：**
```java
@BloodType
private String bloodType;  // 支持：A、B、AB、O、A+、A-、B+、B-、AB+、AB-、O+、O-
```

#### @ISBN - ISBN号验证器

**功能特性：**
- 支持ISBN-10格式
- 支持ISBN-13格式

**使用示例：**
```java
@ISBN
private String isbn;

@ISBN(message = "ISBN号格式不正确")
private String bookIsbn;
```

#### @ChineseNickname - 中文昵称验证器

**功能特性：**
- 支持中文、字母、数字、下划线
- 可配置长度限制

**使用示例：**
```java
@ChineseNickname
private String nickname;

@ChineseNickname(min = 2, max = 16)
private String username;
```

#### @Password - 密码强度验证器

**功能特性：**
- 可配置密码强度等级
- 支持自定义规则

**使用示例：**
```java
@Password
private String password;

@Password(message = "密码强度不符合要求")
private String userPassword;
```

#### @EnumValue - 枚举值验证器

**功能特性：**
- 验证字符串是否为指定枚举的有效值
- 支持忽略大小写匹配

**使用示例：**
```java
public enum UserStatus {
    ACTIVE, INACTIVE, PENDING, SUSPENDED
}

@EnumValue(enumClass = UserStatus.class)
private String status;

@EnumValue(enumClass = UserStatus.class, ignoreCase = true)
private String userStatus;
```

## 四、验证器一览表

| 验证器 | 用途 | 主要参数 | 示例 |
|--------|------|----------|------|
| @Mobile | 手机号验证 | - | 13812345678 |
| @IdCard | 身份证验证 | - | 110101199003074614 |
| @Email | 邮箱验证 | allowSubdomain, allowChinese | user@example.com |
| @BankCard | 银行卡验证 | - | 6222020200012345678 |
| @CVV | CVV码验证 | - | 123, 1234 |
| @CreditCode | 统一社会信用代码 | - | 91110000MA01FXYK3C |
| @PlateNumber | 车牌号验证 | type | 京A12345, 京AD12345 |
| @Telephone | 座机号码验证 | requireAreaCode, allowExtension | 010-12345678 |
| @IpAddress | IP地址验证 | - | 192.168.1.1 |
| @MacAddress | MAC地址验证 | separator, allowNoSeparator | AA:BB:CC:DD:EE:FF |
| @Url | URL验证 | - | https://example.com |
| @QQNumber | QQ号验证 | - | 12345678 |
| @WeChatId | 微信号验证 | - | wxid_abc123 |
| @PostCode | 邮政编码验证 | - | 100000 |
| @BloodType | 血型验证 | - | A+, O- |
| @ISBN | ISBN号验证 | - | 978-7-111-12345-6 |
| @ChineseNickname | 中文昵称验证 | min, max | 张三123 |
| @Password | 密码强度验证 | - | Abc123!@ |
| @EnumValue | 枚举值验证 | enumClass, ignoreCase | ACTIVE |

## 五、完整示例

### 5.1 用户注册场景

```java
@Data
public class UserRegisterRequest {

    @NotBlank(message = "用户名不能为空")
    @ChineseNickname(message = "用户名必须是有效的中文昵称")
    private String username;

    @NotBlank(message = "手机号不能为空")
    @Mobile(message = "手机号格式不正确")
    private String mobile;

    @NotBlank(message = "身份证号不能为空")
    @IdCard(message = "身份证号无效")
    private String idCard;

    @Email(message = "邮箱格式不正确")
    private String email;

    @NotBlank(message = "密码不能为空")
    @Password(message = "密码强度不符合要求")
    private String password;

    @PostCode
    private String postCode;
}

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @PostMapping("/register")
    public ResponseEntity<?> register(
            @Valid @RequestBody UserRegisterRequest request) {

        // 额外的业务验证
        String carrier = MobileValidator.getCarrier(request.getMobile());
        log.info("用户手机号运营商: {}", carrier);

        // 注册逻辑...

        return ResponseEntity.ok(Map.of(
            "success", true,
            "message", "注册成功"
        ));
    }
}
```

### 5.2 企业信息录入场景

```java
@Data
public class EnterpriseDTO {

    @NotBlank(message = "企业名称不能为空")
    private String name;

    @NotBlank(message = "统一社会信用代码不能为空")
    @CreditCode(message = "统一社会信用代码无效")
    private String creditCode;

    @Telephone(requireAreaCode = true, message = "请输入包含区号的座机号码")
    private String telephone;

    @Mobile(message = "联系人手机号格式不正确")
    private String contactMobile;

    @Email(allowSubdomain = false, message = "请输入企业邮箱")
    private String email;

    @PlateNumber(type = PlateNumber.PlateType.ALL)
    private String companyCarPlate;

    @BankCard(message = "请输入有效的银行账号")
    private String bankAccount;

    @Url(message = "企业网站地址格式不正确")
    private String website;

    @PostCode
    private String postCode;
}

@RestController
@RequestMapping("/api/enterprise")
public class EnterpriseController {

    @PostMapping("/register")
    public ResponseEntity<?> registerEnterprise(
            @Valid @RequestBody EnterpriseDTO dto) {

        // 识别车牌类型
        String plateType = PlateNumberValidator.getPlateType(dto.getCompanyCarPlate());
        log.info("车牌类型: {}", plateType);

        // 业务逻辑...

        return ResponseEntity.ok(Map.of(
            "success", true,
            "message", "企业信息录入成功"
        ));
    }
}
```

### 5.3 网络设备管理场景

```java
@Data
public class NetworkDeviceDTO {

    @NotBlank(message = "设备名称不能为空")
    private String deviceName;

    @NotBlank(message = "MAC地址不能为空")
    @MacAddress(separator = ":", allowNoSeparator = false)
    private String macAddress;

    @NotBlank(message = "IP地址不能为空")
    @IpAddress(message = "IP地址格式不正确")
    private String ipAddress;

    @Url(message = "管理地址格式不正确")
    private String managementUrl;

    @Telephone(requireAreaCode = false, allowExtension = true)
    private String supportPhone;

    private String description;
}

@RestController
@RequestMapping("/api/network")
public class NetworkController {

    @PostMapping("/device")
    public ResponseEntity<?> addDevice(
            @Valid @RequestBody NetworkDeviceDTO dto) {

        // 格式化MAC地址
        String formattedMac = MacAddressValidator.format(dto.getMacAddress(), "-");
        log.info("格式化后的MAC地址: {}", formattedMac);

        // 业务逻辑...

        return ResponseEntity.ok(Map.of(
            "success", true,
            "message", "设备添加成功",
            "data", Map.of(
                "deviceName", dto.getDeviceName(),
                "formattedMac", formattedMac
            )
        ));
    }
}
```

### 5.4 社交账号绑定场景

```java
@Data
public class SocialAccountDTO {

    @NotBlank(message = "用户ID不能为空")
    private String userId;

    @QQNumber(message = "QQ号格式不正确")
    private String qqNumber;

    @WeChatId(message = "微信号格式不正确")
    private String wechatId;

    @Email(allowChinese = true, message = "邮箱格式不正确")
    private String email;

    @Mobile(message = "手机号格式不正确")
    private String mobile;

    @EnumValue(enumClass = AccountStatus.class, ignoreCase = true)
    private String status;

    public enum AccountStatus {
        ACTIVE, INACTIVE, VERIFIED, UNVERIFIED
    }
}
```

## 六、高级用法

### 6.1 全局异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleValidationException(
            MethodArgumentNotValidException ex) {

        Map<String, String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .collect(Collectors.toMap(
                FieldError::getField,
                FieldError::getDefaultMessage,
                (existing, replacement) -> existing
            ));

        return ResponseEntity.badRequest().body(Map.of(
            "success", false,
            "message", "参数验证失败",
            "errors", errors
        ));
    }
}
```

### 6.2 分组验证

```java
public interface CreateGroup {}
public interface UpdateGroup {}

@Data
public class UserDTO {

    @Mobile(groups = CreateGroup.class)
    private String mobile;

    @IdCard(groups = {CreateGroup.class, UpdateGroup.class})
    private String idCard;

    @Email(groups = UpdateGroup.class)
    private String email;
}

// Controller中使用
@PostMapping("/create")
public ResponseEntity<?> create(
    @Validated(CreateGroup.class) @RequestBody UserDTO dto) {
    return ResponseEntity.ok("创建成功");
}

@PutMapping("/update")
public ResponseEntity<?> update(
    @Validated(UpdateGroup.class) @RequestBody UserDTO dto) {
    return ResponseEntity.ok("更新成功");
}
```

### 6.3 程序化验证

```java
@Component
public class ValidationService {

    @Autowired
    private Validator validator;

    public void validateObject(Object obj) {
        Set<ConstraintViolation<Object>> violations =
            validator.validate(obj);

        if (!violations.isEmpty()) {
            String errors = violations.stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.joining(", "));
            throw new ValidationException("验证失败: " + errors);
        }
    }

    // 验证特定属性
    public void validateProperty(Object obj, String propertyName) {
        Set<ConstraintViolation<Object>> violations =
            validator.validateProperty(obj, propertyName);

        if (!violations.isEmpty()) {
            throw new ValidationException(
                violations.iterator().next().getMessage()
            );
        }
    }
}
```

### 6.4 自定义错误消息

```java
@Data
public class UserDTO {

    @Mobile(message = "手机号 ${validatedValue} 格式不正确")
    private String mobile;

    @IdCard(message = "{custom.idcard.invalid}")
    private String idCard;
}
```

配置文件 `ValidationMessages.properties`:
```properties
custom.idcard.invalid=身份证号码验证失败，请检查输入
```

### 6.5 条件验证

```java
@Data
public class OrderDTO {

    private String paymentType;

    @BankCard
    @NotNull(groups = BankPaymentGroup.class)
    private String bankCard;

    @CVV
    @NotNull(groups = BankPaymentGroup.class)
    private String cvv;
}
```

### 6.6 数据导入场景

```java
@Service
public class DataImportService {

    @Autowired
    private Validator validator;

    public ImportResult importUsers(List<UserImportDTO> users) {
        ImportResult result = new ImportResult();

        for (int i = 0; i < users.size(); i++) {
            UserImportDTO user = users.get(i);
            Set<ConstraintViolation<UserImportDTO>> violations =
                validator.validate(user);

            if (violations.isEmpty()) {
                // 保存用户
                result.addSuccess(user);
            } else {
                // 记录错误
                String errors = violations.stream()
                    .map(v -> v.getPropertyPath() + ": " + v.getMessage())
                    .collect(Collectors.joining("; "));

                result.addError(i + 1, errors);
            }
        }

        return result;
    }
}
```

## 七、性能优化建议

1. **使用预编译的正则表达式**：所有验证器内部已使用静态的预编译正则表达式
2. **空值处理**：验证器默认对空值返回true，配合@NotNull使用
3. **验证器单例**：所有验证器实例都是单例的，线程安全
4. **批量验证**：对于大量数据验证，建议使用异步处理
5. **缓存验证结果**：对于重复验证的数据，可以考虑缓存验证结果

## 八、常见问题

### Q1: 验证器对空值的处理？
A: 所有验证器对null和空字符串默认返回true，需要配合@NotNull或@NotBlank使用。

### Q2: 如何自定义验证器？
A: 参考现有验证器实现，创建注解和对应的ConstraintValidator实现类：
```java
// 1. 创建注解
@Documented
@Constraint(validatedBy = CustomValidator.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
public @interface Custom {
    String message() default "验证失败";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// 2. 实现验证器
public class CustomValidator implements ConstraintValidator<Custom, String> {
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (StringUtils.isEmpty(value)) {
            return true;
        }
        // 验证逻辑
        return true;
    }
}
```

### Q3: 如何处理验证错误？
A: 推荐使用全局异常处理器统一处理MethodArgumentNotValidException。

### Q4: 支持的Spring Boot版本？
A: 支持Spring Boot 3.x，需要Java 21+。

### Q5: 如何验证集合中的元素？
A: 使用@Valid注解配合集合泛型：
```java
@Valid
private List<@Mobile String> mobileList;
```

### Q6: 如何实现跨字段验证？
A: 可以创建类级别的验证器，或使用@ScriptAssert注解。

## 九、版本信息

- **当前版本**：1.0.0
- **发布日期**：2024-09
- **Spring Boot**：3.4.1
- **Java**：21+
- **Jakarta Validation**：3.x

## 十、更新日志

### Version 1.0.0 (2024-09)
- 初始版本发布
- 包含20+个常用验证器
- 支持Spring Boot 3.x自动配置
- 完整的中国本地化支持
- 新增验证器：
  - 统一社会信用代码验证器
  - 车牌号验证器（支持新能源）
  - MAC地址验证器
  - 座机号码验证器
  - QQ号、微信号验证器
  - 枚举值验证器

## 十一、贡献指南

欢迎提交Issue和Pull Request！

提交新验证器时请确保：
1. 遵循现有代码风格
2. 添加完整的单元测试
3. 更新相关文档
4. 提供使用示例

## 十二、许可证

Apache License 2.0

## 十三、联系支持

如有问题或建议，请联系开发团队或提交Issue到项目仓库。

---

*Moon Spring Boot Starter Validator - 让验证更简单、更可靠、更专业*