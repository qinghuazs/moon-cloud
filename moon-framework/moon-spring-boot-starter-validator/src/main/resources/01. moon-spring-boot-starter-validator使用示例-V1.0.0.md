# Moon Spring Boot Starter Validator 使用文档

**版本：1.0.0**

## 一、简介

Moon Spring Boot Starter Validator 是一个基于 Spring Boot 3.x 的验证器扩展模块，提供了丰富的自定义验证注解，专门针对中国本地化业务场景进行优化。该模块基于 Jakarta Validation API 3.x 构建，无缝集成 Spring Boot 验证框架。

## 二、快速开始

### 2.1 引入依赖

```xml
<dependency>
    <groupId>com.mooncloud</groupId>
    <artifactId>moon-spring-boot-starter-validator</artifactId>
    <version>1.0.0</version>
</dependency>
```

### 2.2 基础使用示例

```java
import com.moon.cloud.validator.mobile.Mobile;
import com.moon.cloud.validator.idcard.IdCard;
import com.moon.cloud.validator.email.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class UserRegisterDTO {

    @NotBlank(message = "手机号不能为空")
    @Mobile(message = "手机号格式不正确")
    private String mobile;

    @NotBlank(message = "身份证号不能为空")
    @IdCard(message = "身份证号格式不正确")
    private String idCard;

    @Email(message = "邮箱格式不正确")
    private String email;
}
```

### 2.3 Controller 集成

```java
@RestController
@RequestMapping("/api/user")
public class UserController {

    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody UserRegisterDTO dto) {
        // 验证通过后的业务逻辑
        return ResponseEntity.ok("注册成功");
    }
}
```

## 三、验证器详细说明

### 3.1 @Mobile - 手机号验证器

#### 功能特性
- 支持中国大陆所有运营商最新号段（包括中国广电192）
- 支持国际区号格式（+86、86前缀）
- 支持带空格和连字符的格式
- 提供运营商识别功能

#### 使用示例
```java
// 基础使用
@Mobile
private String phone;

// 自定义错误消息
@Mobile(message = "请输入正确的手机号码")
private String mobile;
```

#### 支持的格式
```
13812345678      // 标准格式
+8613812345678   // 带国际区号
8613812345678    // 带国家码
138 1234 5678    // 带空格
138-1234-5678    // 带连字符
```

#### 运营商识别
```java
String carrier = MobileValidator.getCarrier("13812345678");
// 返回：中国移动
```

#### 支持的号段
- **中国移动**：134-139, 147, 148, 150-152, 157-159, 165, 172, 178, 182-184, 187-188, 195, 197, 198
- **中国联通**：130-132, 145, 146, 155-156, 166, 167, 171, 175-176, 185-186, 196
- **中国电信**：133, 149, 153, 173-174, 177, 180-181, 189, 190, 191, 193, 199
- **中国广电**：192

### 3.2 @IdCard - 身份证验证器

#### 功能特性
- 支持18位二代身份证号验证
- 验证地区码（省市区）合法性
- 验证出生日期合法性
- 使用ISO 7064:1983.MOD 11-2算法验证校验码
- 支持大小写X校验码

#### 使用示例
```java
@IdCard
private String idCard;

@NotBlank
@IdCard(message = "身份证号码无效")
private String identityCard;
```

#### 验证规则
1. **格式验证**：18位字符，前17位为数字，第18位为数字或X
2. **地区码验证**：前6位必须是有效的行政区划代码
3. **出生日期验证**：
   - 不能晚于当前日期
   - 不能早于1900年
   - 考虑闰年等日期合法性
4. **校验码验证**：按国标算法验证最后一位

### 3.3 @Email - 邮箱验证器

#### 功能特性
- 支持标准RFC邮箱格式
- 可配置是否允许子域名
- 可配置是否允许中文域名
- 支持多种特殊字符

#### 使用示例
```java
// 标准邮箱
@Email
private String email;

// 允许中文域名
@Email(allowChinese = true)
private String chineseEmail;

// 不允许子域名（如mail.example.com）
@Email(allowSubdomain = false)
private String companyEmail;

// 组合配置
@Email(
    allowChinese = true,
    allowSubdomain = false,
    message = "邮箱格式不符合要求"
)
private String customEmail;
```

#### 参数说明
| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| allowSubdomain | boolean | true | 是否允许子域名邮箱 |
| allowChinese | boolean | false | 是否允许中文域名 |
| message | String | "邮箱地址格式不正确" | 验证失败消息 |

### 3.4 @BankCard - 银行卡验证器

#### 功能特性
- 使用Luhn算法验证银行卡号
- 支持16-19位银行卡号

#### 使用示例
```java
@BankCard
private String bankCardNumber;

@BankCard(message = "银行卡号无效")
private String cardNo;
```

### 3.5 @PostCode - 邮政编码验证器

#### 功能特性
- 验证6位中国邮政编码

#### 使用示例
```java
@PostCode
private String postCode;
```

### 3.6 其他验证器

#### @BloodType - 血型验证
```java
@BloodType
private String bloodType;  // 支持：A、B、AB、O、A+、A-、B+、B-、AB+、AB-、O+、O-
```

#### @CVV - CVV码验证
```java
@CVV
private String cvv;  // 3-4位数字
```

#### @IpAddress - IP地址验证
```java
@IpAddress
private String ip;  // 支持IPv4和IPv6
```

#### @ISBN - ISBN号验证
```java
@ISBN
private String isbn;  // 支持ISBN-10和ISBN-13
```

#### @Url - URL验证
```java
@Url
private String website;
```

#### @ChineseNickname - 中文昵称验证
```java
@ChineseNickname
private String nickname;
```

#### @Password - 密码强度验证
```java
@Password
private String password;
```

## 四、高级用法

### 4.1 全局异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleValidationException(
            MethodArgumentNotValidException ex) {

        Map<String, String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .collect(Collectors.toMap(
                FieldError::getField,
                FieldError::getDefaultMessage,
                (existing, replacement) -> existing
            ));

        return ResponseEntity.badRequest().body(Map.of(
            "success", false,
            "message", "参数验证失败",
            "errors", errors
        ));
    }
}
```

### 4.2 分组验证

```java
public interface CreateGroup {}
public interface UpdateGroup {}

@Data
public class UserDTO {

    @Mobile(groups = CreateGroup.class)
    private String mobile;

    @IdCard(groups = {CreateGroup.class, UpdateGroup.class})
    private String idCard;

    @Email(groups = UpdateGroup.class)
    private String email;
}

// Controller中使用
@PostMapping("/create")
public ResponseEntity<?> create(
    @Validated(CreateGroup.class) @RequestBody UserDTO dto) {
    return ResponseEntity.ok("创建成功");
}

@PutMapping("/update")
public ResponseEntity<?> update(
    @Validated(UpdateGroup.class) @RequestBody UserDTO dto) {
    return ResponseEntity.ok("更新成功");
}
```

### 4.3 程序化验证

```java
@Component
public class ValidationService {

    @Autowired
    private Validator validator;

    public void validateObject(Object obj) {
        Set<ConstraintViolation<Object>> violations =
            validator.validate(obj);

        if (!violations.isEmpty()) {
            String errors = violations.stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.joining(", "));
            throw new ValidationException("验证失败: " + errors);
        }
    }

    // 验证特定属性
    public void validateProperty(Object obj, String propertyName) {
        Set<ConstraintViolation<Object>> violations =
            validator.validateProperty(obj, propertyName);

        if (!violations.isEmpty()) {
            throw new ValidationException(
                violations.iterator().next().getMessage()
            );
        }
    }
}
```

### 4.4 自定义错误消息

```java
@Data
public class UserDTO {

    @Mobile(message = "手机号 ${validatedValue} 格式不正确")
    private String mobile;

    @IdCard(message = "{custom.idcard.invalid}")
    private String idCard;
}
```

配置文件 `ValidationMessages.properties`:
```properties
custom.idcard.invalid=身份证号码验证失败，请检查输入
```

### 4.5 条件验证

```java
@Data
public class OrderDTO {

    private String paymentType;

    @BankCard
    @NotNull(groups = BankPaymentGroup.class)
    private String bankCard;

    @CVV
    @NotNull(groups = BankPaymentGroup.class)
    private String cvv;
}
```

## 五、完整示例

### 5.1 用户注册场景

```java
@Data
public class UserRegisterRequest {

    @NotBlank(message = "用户名不能为空")
    @ChineseNickname(message = "用户名必须是有效的中文昵称")
    private String username;

    @NotBlank(message = "手机号不能为空")
    @Mobile(message = "手机号格式不正确")
    private String mobile;

    @NotBlank(message = "身份证号不能为空")
    @IdCard(message = "身份证号无效")
    private String idCard;

    @Email(message = "邮箱格式不正确")
    private String email;

    @NotBlank(message = "密码不能为空")
    @Password(message = "密码强度不符合要求")
    private String password;

    @PostCode
    private String postCode;
}

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @PostMapping("/register")
    public ResponseEntity<?> register(
            @Valid @RequestBody UserRegisterRequest request) {

        // 额外的业务验证
        String carrier = MobileValidator.getCarrier(request.getMobile());
        log.info("用户手机号运营商: {}", carrier);

        // 注册逻辑...

        return ResponseEntity.ok(Map.of(
            "success", true,
            "message", "注册成功"
        ));
    }
}
```

### 5.2 数据导入场景

```java
@Service
public class DataImportService {

    @Autowired
    private Validator validator;

    public ImportResult importUsers(List<UserImportDTO> users) {
        ImportResult result = new ImportResult();

        for (int i = 0; i < users.size(); i++) {
            UserImportDTO user = users.get(i);
            Set<ConstraintViolation<UserImportDTO>> violations =
                validator.validate(user);

            if (violations.isEmpty()) {
                // 保存用户
                result.addSuccess(user);
            } else {
                // 记录错误
                String errors = violations.stream()
                    .map(v -> v.getPropertyPath() + ": " + v.getMessage())
                    .collect(Collectors.joining("; "));

                result.addError(i + 1, errors);
            }
        }

        return result;
    }
}
```

## 六、性能优化建议

1. **使用预编译的正则表达式**：所有验证器内部已使用静态的预编译正则表达式
2. **空值处理**：验证器默认对空值返回true，配合@NotNull使用
3. **验证器单例**：所有验证器实例都是单例的，线程安全
4. **批量验证**：对于大量数据验证，建议使用异步处理

## 七、常见问题

### Q1: 验证器对空值的处理？
A: 所有验证器对null和空字符串默认返回true，需要配合@NotNull或@NotBlank使用。

### Q2: 如何自定义验证器？
A: 参考现有验证器实现，创建注解和对应的ConstraintValidator实现类。

### Q3: 如何处理验证错误？
A: 推荐使用全局异常处理器统一处理MethodArgumentNotValidException。

### Q4: 支持的Spring Boot版本？
A: 支持Spring Boot 3.x，需要Java 21+。

## 八、版本信息

- **当前版本**：1.0.0
- **发布日期**：2024-09
- **Spring Boot**：3.4.1
- **Java**：21+
- **Jakarta Validation**：3.x

## 九、联系支持

如有问题或建议，请联系开发团队或提交Issue。

---

*Moon Spring Boot Starter Validator - 让验证更简单、更可靠*