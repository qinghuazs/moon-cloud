# Redis队列消费实现文档

## 一、功能概述

本功能实现了从Redis队列中消费App URL，调用Express服务获取App详情，并将数据保存到数据库的完整流程。系统支持并发处理、失败重试和错误日志记录。

## 二、核心功能

### 1. 队列消费
- **定时执行**: 每天凌晨3点自动执行消费任务
- **批量处理**: 支持批量获取URL进行并发处理
- **并发控制**: 使用线程池控制并发数量
- **手动触发**: 支持通过API手动触发消费

### 2. 失败重试机制
- **自动重试**: 每30分钟自动重试失败的任务
- **重试次数限制**: 最多重试3次
- **失败记录**: 失败信息记录到数据库

### 3. 数据处理流程
1. 从Redis队列获取App URL
2. 提取URL中的App ID
3. 调用Express服务获取详情
4. 转换数据格式
5. 保存或更新到数据库

## 三、系统架构

```
┌─────────────────┐
│  Redis Queue    │
│  (App URLs)     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Consumer       │◄──── 定时任务 (每天凌晨3点)
│  Service        │
└────────┬────────┘
         │
    ┌────┴────┐
    │并发处理 │
    └────┬────┘
         │
         ▼
┌─────────────────┐
│ Express API     │
│ (获取App详情)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  MySQL DB       │
│  (存储App信息)  │
└─────────────────┘
```

## 四、核心组件

### 1. AppQueueConsumerService
消费服务接口，定义核心功能：
- `consumeAppQueue()`: 消费队列
- `processAppUrl()`: 处理单个URL
- `retryFailedTasks()`: 重试失败任务

### 2. AppQueueConsumerServiceImpl
服务实现类，包含：
- 批量消费逻辑
- 并发处理控制
- 数据转换逻辑
- 失败处理机制

### 3. AppQueueConsumerTask
定时任务类：
- 每天凌晨3点执行消费
- 每30分钟重试失败
- 每天凌晨3点清理过期记录

### 4. AppQueueController
管理接口：
- 查看队列状态
- 手动触发消费
- 手动重试失败任务

## 五、配置参数

```yaml
appstore:
  express:
    url: http://localhost:3090  # Express服务地址
    timeout: 30                  # 请求超时时间
  consumer:
    enabled: true                # 是否启用消费者
    batch-size: 10              # 批量处理大小
    thread-pool-size: 5         # 线程池大小
    max-retry: 3                # 最大重试次数
    timeout: 30                 # 处理超时时间
```

## 六、Redis队列结构

| 队列名称 | Key模式 | 说明 |
|---------|--------|------|
| 分类队列 | appstore:queue:{categoryId} | 按分类存储的App URL队列 |
| 失败队列 | appstore:app:url:failed:queue | 处理失败的URL |
| 处理中集合 | appstore:app:url:processing | 正在处理的URL |

**重要说明**：
- 队列按分类ID分开存储，与CrawlerService保持一致
- 每个分类有独立的队列：`appstore:queue:6014`（游戏类）、`appstore:queue:6018`（教育类）等
- 消费时会并发处理所有分类队列

## 七、数据库表结构

### app_crawl_failures表
```sql
CREATE TABLE `app_crawl_failures` (
  `id` varchar(64) PRIMARY KEY,
  `url` varchar(500) NOT NULL,
  `app_id` varchar(100),
  `error_message` text,
  `retry_count` int DEFAULT 0,
  `status` tinyint DEFAULT 0,
  `created_at` datetime NOT NULL,
  `resolved_at` datetime,
  `remark` varchar(500)
);
```

## 八、API接口

### 1. 获取所有队列状态
```
GET /api/appstore/queue/status
```

响应示例：
```json
{
  "totalQueueSize": 150,
  "failedQueueSize": 2,
  "timestamp": 1695800000000
}
```

### 2. 获取指定分类队列状态
```
GET /api/appstore/queue/status/{categoryId}
```

响应示例：
```json
{
  "categoryId": "6014",
  "queueSize": 25,
  "timestamp": 1695800000000
}
```

### 3. 手动触发所有分类消费
```
POST /api/appstore/queue/consume
```

### 4. 手动触发指定分类消费
```
POST /api/appstore/queue/consume/{categoryId}
```

### 5. 重试失败任务
```
POST /api/appstore/queue/retry
```

### 6. 处理单个URL
```
POST /api/appstore/queue/process?url={url}
```

## 九、使用示例

### 1. 添加URL到队列
```java
// 通过CrawlerService添加URL到队列
redisTemplate.opsForList().leftPush("appstore:app:url:queue", appUrl);
```

### 2. 手动触发消费
```bash
curl -X POST http://localhost:8082/api/appstore/queue/consume
```

### 3. 查看队列状态
```bash
curl http://localhost:8082/api/appstore/queue/status
```

## 十、异常处理

### 1. Express服务不可用
- 记录失败日志
- URL加入失败队列
- 等待下次重试

### 2. 数据转换异常
- 记录详细错误信息
- 保存原始数据用于分析
- 人工介入处理

### 3. 数据库保存失败
- 事务回滚
- 记录失败原因
- 重新加入队列

## 十一、性能优化

### 1. 批量处理
- 每次获取10个URL
- 使用线程池并发处理
- 减少Redis访问次数

### 2. 连接池优化
- HTTP连接池配置
- 数据库连接池优化
- Redis连接池管理

### 3. 缓存策略
- 已处理的App ID缓存
- 避免重复处理
- 定期清理过期缓存

## 十二、监控指标

### 1. 队列指标
- 待处理队列大小
- 失败队列大小
- 处理速度（URL/分钟）

### 2. 成功率指标
- 处理成功率
- 重试成功率
- 平均重试次数

### 3. 性能指标
- 平均处理时间
- Express API响应时间
- 数据库写入时间

## 十三、注意事项

1. **Express服务依赖**: 确保Express服务正常运行
2. **Redis可用性**: 确保Redis服务正常
3. **数据库连接**: 确保数据库连接正常
4. **日志监控**: 定期检查错误日志
5. **队列监控**: 避免队列积压过多

## 十四、后续优化建议

1. 添加消息队列（RabbitMQ/Kafka）替代Redis List
2. 实现分布式锁避免重复消费
3. 添加监控告警机制
4. 实现动态调整并发数
5. 添加数据去重机制
6. 实现增量更新策略