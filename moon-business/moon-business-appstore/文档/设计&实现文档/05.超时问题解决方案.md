# 超时问题解决方案

## 一、问题描述

### 错误现象
```
ERROR c.m.c.a.s.i.AppQueueConsumerServiceImpl - 消费App URL队列异常
java.util.concurrent.TimeoutException: null
```

### 问题原因
1. **超时时间太短**：原设置30秒处理10个URL不够
2. **Express服务响应慢**：出现500错误和socket hang up
3. **超时后整批失败**：TimeoutException导致整个批次终止

## 二、解决方案

### 1. 动态超时时间计算

#### 原实现
```java
// 固定30秒超时
.get(requestTimeout, TimeUnit.SECONDS);
```

#### 改进实现
```java
// 动态计算：每个URL预留60秒，最少300秒
long timeout = Math.max(300, urls.size() * 60L);
.get(timeout, TimeUnit.SECONDS);
```

### 2. 优雅的超时处理

```java
try {
    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .get(timeout, TimeUnit.SECONDS);
    log.info("处理完成 - 成功: {}, 失败: {}", successCount.get(), failCount.get());
} catch (TimeoutException e) {
    log.error("处理超时（{}秒），部分任务可能未完成", timeout);
    // 取消未完成的任务
    futures.forEach(f -> {
        if (!f.isDone()) {
            f.cancel(true);
        }
    });
    // 输出统计信息
    log.info("超时后统计 - 成功: {}, 失败: {}", successCount.get(), failCount.get());
}
```

### 3. 添加处理统计

```java
// 记录处理统计
AtomicInteger successCount = new AtomicInteger(0);
AtomicInteger failCount = new AtomicInteger(0);

// 处理成功时
successCount.incrementAndGet();

// 处理失败时
failCount.incrementAndGet();
```

### 4. 线程池优雅关闭

```java
finally {
    if (executor != null) {
        executor.shutdown();
        try {
            // 等待线程池关闭
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

### 5. 配置优化

```yaml
appstore:
  consumer:
    batch-size: 5  # 减小批量大小，提高成功率
    thread-pool-size: 3  # 减小线程池，避免并发过高
```

## 三、关键改进点

### 1. **超时不再导致任务终止**
- 超时后仍能统计已完成的任务
- 取消未完成的任务，避免资源泄露
- 记录详细的统计信息

### 2. **更合理的超时策略**
- 单个URL处理：60秒
- 批量处理最少：300秒（5分钟）
- 分类队列：每个分类10分钟
- 全部分类：最少1小时

### 3. **更好的错误隔离**
- 每个URL独立处理，互不影响
- 失败的URL进入失败队列
- 成功的任务正常完成

## 四、超时时间计算公式

| 场景 | 计算公式 | 最小值 |
|------|---------|--------|
| 单批URL | urls.size() * 60秒 | 300秒 |
| 单个分类 | 批量超时累加 | 10分钟 |
| 所有分类 | categories.size() * 600秒 | 1小时 |

## 五、错误处理流程

```
开始处理
    ↓
设置动态超时时间
    ↓
并发处理URL
    ↓
等待完成或超时
    ↓
超时？ → 是 → 取消未完成任务 → 记录统计
    ↓ 否
记录成功统计
    ↓
清理资源
```

## 六、监控指标

### 1. 成功率监控
```java
double successRate = (double) successCount.get() / urls.size() * 100;
log.info("处理成功率: {:.2f}%", successRate);
```

### 2. 超时监控
- 记录超时发生次数
- 记录超时时的完成情况
- 分析超时原因

### 3. 性能监控
- 平均处理时间
- Express服务响应时间
- 数据库写入时间

## 七、进一步优化建议

### 1. 熔断机制
当Express服务连续失败时，暂停消费，避免大量失败。

### 2. 降级策略
Express服务不可用时，将URL重新入队，延后处理。

### 3. 限流控制
控制对Express服务的并发请求数，避免压垮服务。

### 4. 重试策略优化
- 指数退避重试
- 分级重试队列
- 死信队列处理

## 八、配置建议

### 开发环境
```yaml
batch-size: 2
thread-pool-size: 2
```

### 测试环境
```yaml
batch-size: 5
thread-pool-size: 3
```

### 生产环境
```yaml
batch-size: 10
thread-pool-size: 5
```

## 九、故障恢复

### 1. Express服务恢复后
- 手动触发失败队列重试
- 检查失败记录数据库

### 2. 超时频繁发生
- 检查Express服务性能
- 调整批量大小和线程数
- 增加超时时间

### 3. 大量失败
- 暂停定时任务
- 分析失败原因
- 修复后重新启动